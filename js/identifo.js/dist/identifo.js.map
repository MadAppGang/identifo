{"version":3,"file":"identifo.js","sources":["../src/api/model.ts","../src/api/api.ts","../src/constants.ts","../src/store-manager/cookie-storage.ts","../src/store-manager/storage-manager.ts","../src/store-manager/local-storage.ts","../src/store-manager/session-storage.ts","../src/tokenService.ts","../src/UrlBuilder.ts","../src/IdentifoAuth.ts"],"sourcesContent":["/* eslint-disable camelcase */\nexport enum APIErrorCodes {\n  PleaseEnableTFA = 'error.api.request.2fa.please_enable',\n  NetworkError = 'error.network',\n}\n\nexport enum TFAType {\n  TFATypeApp = 'app',\n  TFATypeSMS = 'sms',\n  TFATypeEmail = 'email',\n}\n\nexport enum TFAStatus {\n  DISABLED = 'disabled',\n  OPTIONAL = 'optional',\n  MANDATORY = 'mandatory',\n}\nexport interface ApiRequestError {\n  error: {\n    detailed_message?: string;\n    id?: APIErrorCodes;\n    message?: string;\n    status?: number;\n  };\n}\nexport class ApiError extends Error {\n  detailedMessage?: string;\n\n  id?: APIErrorCodes;\n\n  status?: number;\n\n  constructor(error?: ApiRequestError['error']) {\n    super(error?.message || 'Unknown API error');\n    this.detailedMessage = error?.detailed_message;\n    this.id = error?.id;\n    this.status = error?.status;\n  }\n}\nexport interface LoginResponse {\n  access_token?: string;\n  refresh_token?: string;\n  require_2fa: boolean;\n  enabled_2fa: boolean;\n  user: {\n    active: boolean;\n    email?: string;\n    id: string;\n    latest_login_time: number;\n    num_of_logins: number;\n    username?: string;\n    tfa_info: { hotp_expired_at: string };\n    phone?: string;\n  };\n  scopes?: string[];\n  callbackUrl?: string;\n}\nexport interface EnableTFAResponse {\n  provisioning_uri?: string;\n  provisioning_qr?: string;\n  access_token?: string;\n}\nexport interface TokenResponse {\n  access_token?: string;\n  refresh_token?: string;\n}\nexport interface AppSettingsResponse {\n  anonymousResitrationAllowed: boolean;\n  active: boolean;\n  description: string;\n  id: string;\n  newUserDefaultRole: string;\n  offline: boolean;\n  registrationForbidden: boolean;\n  tfaType: TFAType;\n  tfaStatus: TFAStatus;\n  federatedProviders: string[];\n}\n\nexport interface User {\n  id: string;\n  username: string;\n  email: string;\n  phone: string;\n  active: boolean;\n  tfa_info: {\n    is_enabled: boolean;\n  };\n  num_of_logins: number;\n  latest_login_time: number;\n  access_role: string;\n  anonymous: boolean;\n  federated_ids: string[];\n}\nexport interface UpdateUser {\n  new_email?: string;\n  new_phone?: string;\n}\nexport interface SuccessResponse {\n  result: 'ok';\n}\n\nexport interface TFARequiredRespopnse {\n  result: 'tfa-required';\n}\n\nexport type FederatedLoginProvider = 'apple' | 'google' | 'facebook';\n","import TokenService from '../tokenService';\nimport { IdentifoConfig } from '../types/types';\nimport {\n  AppSettingsResponse,\n  EnableTFAResponse,\n  LoginResponse,\n  SuccessResponse,\n  UpdateUser,\n  User,\n  ApiRequestError,\n  ApiError,\n  APIErrorCodes,\n  FederatedLoginProvider,\n  TokenResponse,\n  TFARequiredRespopnse,\n} from './model';\n\nconst APP_ID_HEADER_KEY = 'X-Identifo-Clientid';\nconst AUTHORIZATION_HEADER_KEY = 'Authorization';\n\nexport class Api {\n  baseUrl: string;\n\n  appId: string;\n\n  defaultHeaders = {\n    [APP_ID_HEADER_KEY]: '',\n    Accept: 'application/json',\n    'Content-Type': 'application/json',\n  };\n\n  catchNetworkErrorHandler = (e: TypeError): never => {\n    if (\n      e.message === 'Network Error' ||\n      e.message === 'Failed to fetch' ||\n      e.message === 'Preflight response is not successful' ||\n      e.message.indexOf('is not allowed by Access-Control-Allow-Origin') > -1\n    ) {\n      // eslint-disable-next-line no-console\n      console.error(e.message);\n      throw new ApiError({\n        id: APIErrorCodes.NetworkError,\n        status: 0,\n        message: 'Configuration error',\n        detailed_message:\n          'Please check Identifo URL and add \"' +\n          `${window.location.protocol}//${window.location.host}\" ` +\n          'to \"REDIRECT URLS\" in Identifo app settings.',\n      });\n    }\n    throw e;\n  };\n\n  checkStatusCodeAndGetJSON = async (r: Response): Promise<any> => {\n    if (!r.ok) {\n      const error = (await r.json()) as ApiRequestError;\n      throw new ApiError(error?.error);\n    }\n    return r.json();\n  };\n\n  constructor(private config: IdentifoConfig, private tokenService: TokenService) {\n    // remove trailing slash if exist\n    this.baseUrl = config.url.replace(/\\/$/, '');\n    this.defaultHeaders[APP_ID_HEADER_KEY] = config.appId;\n    this.appId = config.appId;\n  }\n\n  get<T>(path: string, options?: RequestInit): Promise<T> {\n    return this.send(path, { method: 'GET', ...options });\n  }\n\n  put<T>(path: string, data: unknown, options?: RequestInit): Promise<T> {\n    return this.send(path, { method: 'PUT', body: JSON.stringify(data), ...options });\n  }\n\n  post<T>(path: string, data: unknown, options?: RequestInit): Promise<T> {\n    return this.send(path, { method: 'POST', body: JSON.stringify(data), ...options });\n  }\n\n  send<T>(path: string, options?: RequestInit): Promise<T> {\n    const init = { ...options };\n    init.credentials = 'include';\n    init.headers = {\n      ...init.headers,\n      ...this.defaultHeaders,\n    };\n    return fetch(`${this.baseUrl}${path}`, init)\n      .catch(this.catchNetworkErrorHandler)\n      .then(this.checkStatusCodeAndGetJSON)\n      .then((value) => value as T);\n  }\n\n  async getUser(): Promise<User> {\n    if (!this.tokenService.getToken()?.token) {\n      throw new Error('No token in token service.');\n    }\n    return this.get<User>('/me', {\n      headers: {\n        [AUTHORIZATION_HEADER_KEY]: `Bearer ${this.tokenService.getToken()?.token}`,\n      },\n    });\n  }\n\n  async renewToken(): Promise<LoginResponse> {\n    if (!this.tokenService.getToken('refresh')?.token) {\n      throw new Error('No token in token service.');\n    }\n    return this.post<LoginResponse>(\n      '/auth/token',\n      { scopes: this.config.scopes },\n      {\n        headers: {\n          [AUTHORIZATION_HEADER_KEY]: `Bearer ${this.tokenService.getToken('refresh')?.token}`,\n        },\n      },\n    ).then((r) => this.storeToken(r));\n  }\n\n  async updateUser(user: UpdateUser): Promise<User> {\n    if (!this.tokenService.getToken()?.token) {\n      throw new Error('No token in token service.');\n    }\n    return this.put<User>('/me', user, {\n      headers: {\n        [AUTHORIZATION_HEADER_KEY]: `Bearer ${this.tokenService.getToken('access')?.token}`,\n      },\n    });\n  }\n\n  async login(email: string, password: string, deviceToken: string, scopes: string[]): Promise<LoginResponse> {\n    const data = {\n      email,\n      password,\n      device_token: deviceToken,\n      scopes,\n    };\n\n    return this.post<LoginResponse>('/auth/login', data).then((r) => this.storeToken(r));\n  }\n  // After complete login on provider browser will be redirected to redirectUrl\n  // callbackUrl will be stored in sesson and returned after successfull login complete\n  async federatedLogin(\n    provider: FederatedLoginProvider,\n    scopes: string[],\n    redirectUrl: string,\n    callbackUrl?: string,\n    opts: { width?: number; height?: number; popUp?: boolean } = { width: 600, height: 800, popUp: false },\n  ) {\n    var dataForm = document.createElement('form');\n    dataForm.style.display = 'none';\n    if (opts.popUp) {\n      dataForm.target = 'TargetWindow'; //Make sure the window name is same as this value\n    }\n    dataForm.method = 'POST';\n    const params = new URLSearchParams();\n    params.set('appId', this.config.appId);\n    params.set('provider', provider);\n    params.set('scopes', scopes.join(','));\n    params.set('redirectUrl', redirectUrl);\n    if (callbackUrl) {\n      params.set('callbackUrl', callbackUrl);\n    }\n    dataForm.action = `${this.baseUrl}/auth/federated?${params.toString()}`;\n\n    document.body.appendChild(dataForm);\n\n    if (opts.popUp) {\n      const left = window.screenX + window.outerWidth / 2 - (opts.width || 600) / 2;\n      const top = window.screenY + window.outerHeight / 2 - (opts.height || 800) / 2;\n      var postWindow = window.open(\n        '',\n        'TargetWindow',\n        `status=0,title=0,height=${opts.height},width=${opts.width},top=${top},left=${left},scrollbars=1`,\n      );\n      if (postWindow) {\n        dataForm.submit();\n      }\n    } else {\n      window.location.assign(`${this.baseUrl}/auth/federated?${params.toString()}`);\n      // dataForm.submit();\n    }\n  }\n\n  async federatedLoginComplete(params: URLSearchParams): Promise<LoginResponse> {\n    return this.get<LoginResponse>(`/auth/federated/complete?${params.toString()}`).then((r) => this.storeToken(r));\n  }\n\n  async register(email: string, password: string, scopes: string[]): Promise<LoginResponse> {\n    const data = {\n      email,\n      password,\n      scopes,\n    };\n\n    return this.post<LoginResponse>('/auth/register', data).then((r) => this.storeToken(r));\n  }\n\n  async requestResetPassword(email: string, tfaCode?: string): Promise<SuccessResponse | TFARequiredRespopnse> {\n    const data = {\n      email,\n      tfa_code: tfaCode,\n    };\n\n    return this.post<SuccessResponse | TFARequiredRespopnse>('/auth/request_reset_password', data);\n  }\n\n  async resetPassword(password: string): Promise<SuccessResponse> {\n    if (!this.tokenService.getToken()?.token) {\n      throw new Error('No token in token service.');\n    }\n    const data = {\n      password,\n    };\n\n    return this.post<SuccessResponse>('/auth/reset_password', data, {\n      headers: {\n        [AUTHORIZATION_HEADER_KEY]: `Bearer ${this.tokenService.getToken()?.token}`,\n      },\n    });\n  }\n\n  async getAppSettings(): Promise<AppSettingsResponse> {\n    return this.get<AppSettingsResponse>('/auth/app_settings');\n  }\n\n  async enableTFA(): Promise<EnableTFAResponse> {\n    if (!this.tokenService.getToken()?.token) {\n      throw new Error('No token in token service.');\n    }\n    return this.put<EnableTFAResponse>(\n      '/auth/tfa/enable',\n      {},\n      {\n        headers: { [AUTHORIZATION_HEADER_KEY]: `BEARER ${this.tokenService.getToken()?.token}` },\n      },\n    ).then((r) => this.storeToken(r));\n  }\n\n  async verifyTFA(code: string, scopes: string[]): Promise<LoginResponse> {\n    if (!this.tokenService.getToken()?.token) {\n      throw new Error('No token in token service.');\n    }\n    return this.post<LoginResponse>(\n      '/auth/tfa/login',\n      { tfa_code: code, scopes },\n      { headers: { [AUTHORIZATION_HEADER_KEY]: `BEARER ${this.tokenService.getToken()?.token}` } },\n    ).then((r) => this.storeToken(r));\n  }\n\n  async logout(): Promise<SuccessResponse> {\n    if (!this.tokenService.getToken()?.token) {\n      throw new Error('No token in token service.');\n    }\n    return this.post<SuccessResponse>(\n      '/me/logout',\n      {\n        refresh_token: this.tokenService.getToken('refresh')?.token,\n      },\n      {\n        headers: {\n          [AUTHORIZATION_HEADER_KEY]: `Bearer ${this.tokenService.getToken()?.token}`,\n        },\n      },\n    );\n  }\n\n  storeToken<T extends TokenResponse>(response: T): T {\n    if (response.access_token) {\n      this.tokenService.saveToken(response.access_token, 'access');\n    }\n    if (response.refresh_token) {\n      this.tokenService.saveToken(response.refresh_token, 'refresh');\n    }\n    return response;\n  }\n}\n","export const jwtRegex = /^([a-zA-Z0-9_=]+)\\.([a-zA-Z0-9_=]+)\\.([a-zA-Z0-9_\\-=]*$)/;\n\n// Error messages\n\nexport const INVALID_TOKEN_ERROR = 'Empty or invalid token';\n\n// url query params keys\nexport const TOKEN_QUERY_KEY = 'token';\nexport const REFRESH_TOKEN_QUERY_KEY = 'refresh_token';\n","class CookieStorage {\n  isAccessible = false;\n\n  saveToken(): boolean {\n    return true;\n  }\n\n  getToken(): string {\n    throw new Error('Can not get token from HttpOnly');\n  }\n\n  deleteToken(): void {\n    // throw new Error('Can not get token from HttpOnly');\n  }\n}\n\nexport default CookieStorage;\n","import { TokenManager, TokenType } from '../types/types';\n\nclass StorageManager implements TokenManager {\n  preffix = 'identifo_';\n\n  storageType: 'localStorage' | 'sessionStorage' = 'localStorage';\n\n  access = `${this.preffix}access_token`;\n\n  refresh = `${this.preffix}refresh_token`;\n\n  isAccessible = true;\n\n  constructor(storageType: 'localStorage' | 'sessionStorage', accessKey?: string, refreshKey?: string) {\n    this.access = accessKey ? this.preffix + accessKey : this.access;\n    this.refresh = refreshKey ? this.preffix + refreshKey : this.refresh;\n    this.storageType = storageType;\n  }\n\n  saveToken(token: string, tokenType: TokenType): boolean {\n    if (token) {\n      window[this.storageType].setItem(this[tokenType], token);\n      return true;\n    }\n    return false;\n  }\n\n  getToken(tokenType: TokenType): string {\n    return window[this.storageType].getItem(this[tokenType]) ?? '';\n  }\n\n  deleteToken(tokenType: TokenType): void {\n    window[this.storageType].removeItem(this[tokenType]);\n  }\n}\n\nexport default StorageManager;\n","import StorageManager from './storage-manager';\n\nclass LocalStorage extends StorageManager {\n  constructor(accessKey?: string, refreshKey?: string) {\n    super('localStorage', accessKey, refreshKey);\n  }\n}\n\nexport default LocalStorage;\n","import StorageManager from './storage-manager';\n\nclass SessionStorage extends StorageManager {\n  constructor(accessKey?: string, refreshKey?: string) {\n    super('sessionStorage', accessKey, refreshKey);\n  }\n}\n\nexport default SessionStorage;\n","import { INVALID_TOKEN_ERROR } from './constants';\nimport { LocalStorageManager } from './store-manager';\nimport {\n  ClientToken, JWTPayload, TokenManager, TokenType,\n} from './types/types';\n\nclass TokenService {\n  private tokenManager: TokenManager;\n\n  constructor(tokenManager?: TokenManager) {\n    this.tokenManager = tokenManager || new LocalStorageManager();\n    // TODO: implement cookie as default\n    // this.tokenManager = tokenManager || new CoockieStorage();\n  }\n\n  async handleVerification(token: string, audience: string, issuer?: string): Promise<boolean> {\n    if (!this.tokenManager.isAccessible) return true;\n    try {\n      await this.validateToken(token, audience, issuer);\n      this.saveToken(token);\n      return true;\n    } catch (err) {\n      this.removeToken();\n      return Promise.reject(err);\n    }\n  }\n\n  async validateToken(token: string, audience: string, issuer?: string): Promise<boolean> {\n    if (!token) throw new Error(INVALID_TOKEN_ERROR);\n    const jwtPayload = this.parseJWT(token);\n    const isJwtExpired = this.isJWTExpired(jwtPayload);\n    if (jwtPayload.aud?.includes(audience) && (!issuer || jwtPayload.iss === issuer) && !isJwtExpired) {\n      return Promise.resolve(true);\n    }\n    throw new Error(INVALID_TOKEN_ERROR);\n  }\n\n  parseJWT(token: string): JWTPayload {\n    const base64Url = token.split('.')[1];\n    if (!base64Url) return { aud: [], iss: '', exp: 10 };\n    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n    const jsonPayload = decodeURIComponent(\n      atob(base64)\n        .split('')\n        .map((c) => `%${`00${c.charCodeAt(0).toString(16)}`.slice(-2)}`)\n        .join(''),\n    );\n    return JSON.parse(jsonPayload) as JWTPayload;\n  }\n\n  isJWTExpired(token: JWTPayload): boolean {\n    const now = new Date().getTime() / 1000;\n    if (token.exp && now > token.exp) {\n      return true;\n    }\n    return false;\n  }\n\n  isAuthenticated(audience: string, issuer?: string): Promise<boolean> {\n    if (!this.tokenManager.isAccessible) return Promise.resolve(true);\n    const token = this.tokenManager.getToken('access');\n    // TODO: may be change to handleAuth instead validateToken\n    return this.validateToken(token, audience, issuer);\n  }\n\n  saveToken(token: string, type: TokenType = 'access'): boolean {\n    return this.tokenManager.saveToken(token, type);\n  }\n\n  removeToken(type: TokenType = 'access'): void {\n    this.tokenManager.deleteToken(type);\n  }\n\n  getToken(type: TokenType = 'access'): ClientToken | null {\n    const token = this.tokenManager.getToken(type);\n    if (!token) return null;\n    const jwtPayload = this.parseJWT(token);\n    return { token, payload: jwtPayload };\n  }\n}\n\nexport default TokenService;\n","import { IdentifoConfig, UrlFlows } from './types/types';\n\nexport class UrlBuilder {\n  constructor(private config: IdentifoConfig) { }\n\n  getUrl(flow: UrlFlows): string {\n    const scopes = this.config.scopes?.join() || '';\n    const redirectUri = encodeURIComponent(this.config.redirectUri ?? window.location.href);\n    const baseParams = `appId=${this.config.appId}&scopes=${scopes}`;\n    const urlParams = `${baseParams}&callbackUrl=${redirectUri}`;\n    // if postLogoutRedirectUri is empty, login url will be instead\n    const postLogoutRedirectUri = this.config.postLogoutRedirectUri ?\n      `&callbackUrl=${encodeURIComponent(this.config.postLogoutRedirectUri)}` :\n      `&callbackUrl=${redirectUri}&redirectUri=${this.config.url}/web/login?${encodeURIComponent(baseParams)}`;\n\n    const urls = {\n      signup: `${this.config.url}/web/register?${urlParams}`,\n      signin: `${this.config.url}/web/login?${urlParams}`,\n      logout: `${this.config.url}/web/logout?${baseParams}${postLogoutRedirectUri}`,\n      renew: `${this.config.url}/web/token/renew?${baseParams}&redirectUri=${redirectUri}`,\n      default: 'default',\n    };\n\n    return urls[flow] || urls.default;\n  }\n\n  createSignupUrl(): string {\n    return this.getUrl('signup');\n  }\n\n  createSigninUrl(): string {\n    return this.getUrl('signin');\n  }\n\n  createLogoutUrl(): string {\n    return this.getUrl('logout');\n  }\n\n  createRenewSessionUrl(): string {\n    return this.getUrl('renew');\n  }\n}\n","import { Api } from './api/api';\nimport { jwtRegex, REFRESH_TOKEN_QUERY_KEY, TOKEN_QUERY_KEY } from './constants';\nimport TokenService from './tokenService';\nimport { ClientToken, IdentifoConfig, UrlBuilderInit } from './types/types';\nimport { UrlBuilder } from './UrlBuilder';\n\nclass IdentifoAuth {\n  public api: Api;\n\n  public tokenService: TokenService;\n\n  public config: IdentifoConfig;\n\n  public urlBuilder: UrlBuilderInit;\n\n  private token: ClientToken | null = null;\n\n  isAuth = false;\n\n  constructor(config: IdentifoConfig) {\n    this.config = { ...config, autoRenew: config.autoRenew ?? true };\n    this.tokenService = new TokenService(config.tokenManager);\n    this.urlBuilder = new UrlBuilder(this.config);\n    this.api = new Api(config, this.tokenService);\n    this.handleToken(this.tokenService.getToken()?.token || '', 'access');\n  }\n\n  private handleToken(token: string, tokenType: 'access' | 'refresh') {\n    if (token) {\n      if (tokenType === 'access') {\n        const payload = this.tokenService.parseJWT(token);\n        this.token = { token, payload };\n        this.isAuth = true;\n        this.tokenService.saveToken(token);\n      } else {\n        this.tokenService.saveToken(token, 'refresh');\n      }\n    }\n  }\n\n  private resetAuthValues() {\n    this.token = null;\n    this.isAuth = false;\n    this.tokenService.removeToken();\n    this.tokenService.removeToken('refresh');\n  }\n\n  signup(): void {\n    window.location.href = this.urlBuilder.createSignupUrl();\n  }\n\n  signin(): void {\n    window.location.href = this.urlBuilder.createSigninUrl();\n  }\n\n  logout(): void {\n    this.resetAuthValues();\n    window.location.href = this.urlBuilder.createLogoutUrl();\n  }\n\n  async handleAuthentication(): Promise<boolean> {\n    const { access, refresh } = this.getTokenFromUrl();\n    if (!access) {\n      this.resetAuthValues();\n      return Promise.reject();\n    }\n    try {\n      await this.tokenService.handleVerification(access, this.config.appId, this.config.issuer);\n      this.handleToken(access, 'access');\n      if (refresh) {\n        this.handleToken(refresh, 'refresh');\n      }\n      return await Promise.resolve(true);\n    } catch (err) {\n      this.resetAuthValues();\n      return await Promise.reject();\n    } finally {\n      window.history.pushState({}, document.title, window.location.pathname )\n    }\n  }\n\n  private getTokenFromUrl(): { access: string; refresh: string } {\n    const urlParams = new URLSearchParams(window.location.search);\n    const tokens = { access: '', refresh: '' };\n    const accessToken = urlParams.get(TOKEN_QUERY_KEY);\n    const refreshToken = urlParams.get(REFRESH_TOKEN_QUERY_KEY);\n    if (refreshToken && jwtRegex.test(refreshToken)) {\n      tokens.refresh = refreshToken;\n    }\n    if (accessToken && jwtRegex.test(accessToken)) {\n      tokens.access = accessToken;\n    }\n    return tokens;\n  }\n\n  async getToken(): Promise<ClientToken | null> {\n    const token = this.tokenService.getToken();\n    const refreshToken = this.tokenService.getToken('refresh');\n    if (token) {\n      const isExpired = this.tokenService.isJWTExpired(token.payload);\n      if (isExpired && refreshToken) {\n        try {\n          await this.renewSession();\n          return await Promise.resolve(this.token);\n        } catch (err) {\n          this.resetAuthValues();\n          throw new Error('No token');\n        }\n      }\n      return Promise.resolve(token);\n    }\n    return Promise.resolve(null);\n  }\n\n  async renewSession(): Promise<string> {\n    try {\n      const { access, refresh } = await this.renewSessionWithToken();\n      this.handleToken(access, 'access');\n      this.handleToken(refresh, 'refresh');\n      return await Promise.resolve(access);\n    } catch (err) {\n      return Promise.reject();\n    }\n  }\n\n  private async renewSessionWithToken(): Promise<{ access: string, refresh: string }> {\n    try {\n      const tokens = await this.api.renewToken()\n        .then((l) => ({ access: l.access_token || '', refresh: l.refresh_token || '' }));\n      return tokens;\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n}\nexport default IdentifoAuth;\n"],"names":["APIErrorCodes","TFAType","TFAStatus","__async","__spreadValues","LocalStorageManager"],"mappings":";;;;AACYA;AAAL,UAAK,gBAAL;AACL,sCAAkB;AAClB,mCAAe;AAAA,GAFLA;AAKAC;AAAL,UAAK,UAAL;AACL,2BAAa;AACb,2BAAa;AACb,6BAAe;AAAA,GAHLA;AAMAC;AAAL,UAAK,YAAL;AACL,2BAAW;AACX,2BAAW;AACX,4BAAY;AAAA,GAHFA;uBAakB,MAAM;AAAA,EAOlC,YAAY,OAAkC;AAC5C,UAAM,gCAAO,YAAW;AACxB,SAAK,kBAAkB,+BAAO;AAC9B,SAAK,KAAK,+BAAO;AACjB,SAAK,SAAS,+BAAO;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBzB,MAAM,oBAAoB;AAC1B,MAAM,2BAA2B;UAEhB;AAAA,EAyCf,YAAoB,QAAgC,cAA4B;AAA5D;AAAgC;AApCpD,0BAAiB;AAAA,OACd,oBAAoB;AAAA,MACrB,QAAQ;AAAA,MACR,gBAAgB;AAAA;AAGlB,oCAA2B,CAAC,MAAwB;AAClD,UACE,EAAE,YAAY,mBACd,EAAE,YAAY,qBACd,EAAE,YAAY,0CACd,EAAE,QAAQ,QAAQ,mDAAmD,IACrE;AAEA,gBAAQ,MAAM,EAAE;AAChB,cAAM,IAAI,SAAS;AAAA,UACjB,IAAIF,sBAAc;AAAA,UAClB,QAAQ;AAAA,UACR,SAAS;AAAA,UACT,kBACE,sCACG,OAAO,SAAS,aAAa,OAAO,SAAS;AAAA;AAAA;AAItD,YAAM;AAAA;AAGR,qCAA4B,CAAO,MAA8BG;AAC/D,UAAI,CAAC,EAAE,IAAI;AACT,cAAM,QAAS,MAAM,EAAE;AACvB,cAAM,IAAI,SAAS,+BAAO;AAAA;AAE5B,aAAO,EAAE;AAAA;AAKT,SAAK,UAAU,OAAO,IAAI,QAAQ,OAAO;AACzC,SAAK,eAAe,qBAAqB,OAAO;AAChD,SAAK,QAAQ,OAAO;AAAA;AAAA,EAGtB,IAAO,MAAc,SAAmC;AACtD,WAAO,KAAK,KAAK,MAAMC,mBAAE,QAAQ,SAAU;AAAA;AAAA,EAG7C,IAAO,MAAc,MAAe,SAAmC;AACrE,WAAO,KAAK,KAAK,MAAMA,mBAAE,QAAQ,OAAO,MAAM,KAAK,UAAU,SAAU;AAAA;AAAA,EAGzE,KAAQ,MAAc,MAAe,SAAmC;AACtE,WAAO,KAAK,KAAK,MAAMA,mBAAE,QAAQ,QAAQ,MAAM,KAAK,UAAU,SAAU;AAAA;AAAA,EAG1E,KAAQ,MAAc,SAAmC;AACvD,UAAM,OAAOA,qBAAK;AAClB,SAAK,cAAc;AACnB,SAAK,UAAUA,sCACV,KAAK,UACL,KAAK;AAEV,WAAO,MAAM,GAAG,KAAK,UAAU,QAAQ,MACpC,MAAM,KAAK,0BACX,KAAK,KAAK,2BACV,KAAK,CAAC,UAAU;AAAA;AAAA,EAGf,UAAyB;AAAA;AA7FjC;AA8FI,UAAI,aAAM,aAAa,eAAlB,mBAA8B,QAAO;AACxC,cAAM,IAAI,MAAM;AAAA;AAElB,aAAO,KAAK,IAAU,OAAO;AAAA,QAC3B,SAAS;AAAA,WACN,2BAA2B,UAAU,WAAK,aAAa,eAAlB,mBAA8B;AAAA;AAAA;AAAA;AAAA;AAAA,EAKpE,aAAqC;AAAA;AAxG7C;AAyGI,UAAI,aAAM,aAAa,SAAS,eAA3B,mBAAuC,QAAO;AACjD,cAAM,IAAI,MAAM;AAAA;AAElB,aAAO,KAAK,KACV,eACA,EAAE,QAAQ,KAAK,OAAO,UACtB;AAAA,QACE,SAAS;AAAA,WACN,2BAA2B,UAAU,WAAK,aAAa,SAAS,eAA3B,mBAAuC;AAAA;AAAA,SAGjF,KAAK,CAAC,MAAM,KAAK,WAAW;AAAA;AAAA;AAAA,EAG1B,WAAW,MAAiC;AAAA;AAvHpD;AAwHI,UAAI,aAAM,aAAa,eAAlB,mBAA8B,QAAO;AACxC,cAAM,IAAI,MAAM;AAAA;AAElB,aAAO,KAAK,IAAU,OAAO,MAAM;AAAA,QACjC,SAAS;AAAA,WACN,2BAA2B,UAAU,WAAK,aAAa,SAAS,cAA3B,mBAAsC;AAAA;AAAA;AAAA;AAAA;AAAA,EAK5E,MAAM,OAAe,UAAkB,aAAqB,QAA0C;AAAA;AAC1G,YAAM,OAAO;AAAA,QACX;AAAA,QACA;AAAA,QACA,cAAc;AAAA,QACd;AAAA;AAGF,aAAO,KAAK,KAAoB,eAAe,MAAM,KAAK,CAAC,MAAM,KAAK,WAAW;AAAA;AAAA;AAAA,EAI7E,eACJ,IACA,IACA,IACA,IAEA;AAAA,iDALA,UACA,QACA,aACA,aACA,OAA6D,EAAE,OAAO,KAAK,QAAQ,KAAK,OAAO,SAC/F;AACA,UAAI,WAAW,SAAS,cAAc;AACtC,eAAS,MAAM,UAAU;AACzB,UAAI,KAAK,OAAO;AACd,iBAAS,SAAS;AAAA;AAEpB,eAAS,SAAS;AAClB,YAAM,SAAS,IAAI;AACnB,aAAO,IAAI,SAAS,KAAK,OAAO;AAChC,aAAO,IAAI,YAAY;AACvB,aAAO,IAAI,UAAU,OAAO,KAAK;AACjC,aAAO,IAAI,eAAe;AAC1B,UAAI,aAAa;AACf,eAAO,IAAI,eAAe;AAAA;AAE5B,eAAS,SAAS,GAAG,KAAK,0BAA0B,OAAO;AAE3D,eAAS,KAAK,YAAY;AAE1B,UAAI,KAAK,OAAO;AACd,cAAM,OAAO,OAAO,UAAU,OAAO,aAAa,IAAK,MAAK,SAAS,OAAO;AAC5E,cAAM,MAAM,OAAO,UAAU,OAAO,cAAc,IAAK,MAAK,UAAU,OAAO;AAC7E,YAAI,aAAa,OAAO,KACtB,IACA,gBACA,2BAA2B,KAAK,gBAAgB,KAAK,aAAa,YAAY;AAEhF,YAAI,YAAY;AACd,mBAAS;AAAA;AAAA,aAEN;AACL,eAAO,SAAS,OAAO,GAAG,KAAK,0BAA0B,OAAO;AAAA;AAAA;AAAA;AAAA,EAK9D,uBAAuB,QAAiD;AAAA;AAC5E,aAAO,KAAK,IAAmB,4BAA4B,OAAO,cAAc,KAAK,CAAC,MAAM,KAAK,WAAW;AAAA;AAAA;AAAA,EAGxG,SAAS,OAAe,UAAkB,QAA0C;AAAA;AACxF,YAAM,OAAO;AAAA,QACX;AAAA,QACA;AAAA,QACA;AAAA;AAGF,aAAO,KAAK,KAAoB,kBAAkB,MAAM,KAAK,CAAC,MAAM,KAAK,WAAW;AAAA;AAAA;AAAA,EAGhF,qBAAqB,OAAe,SAAmE;AAAA;AAC3G,YAAM,OAAO;AAAA,QACX;AAAA,QACA,UAAU;AAAA;AAGZ,aAAO,KAAK,KAA6C,gCAAgC;AAAA;AAAA;AAAA,EAGrF,cAAc,UAA4C;AAAA;AA/MlE;AAgNI,UAAI,aAAM,aAAa,eAAlB,mBAA8B,QAAO;AACxC,cAAM,IAAI,MAAM;AAAA;AAElB,YAAM,OAAO;AAAA,QACX;AAAA;AAGF,aAAO,KAAK,KAAsB,wBAAwB,MAAM;AAAA,QAC9D,SAAS;AAAA,WACN,2BAA2B,UAAU,WAAK,aAAa,eAAlB,mBAA8B;AAAA;AAAA;AAAA;AAAA;AAAA,EAKpE,iBAA+C;AAAA;AACnD,aAAO,KAAK,IAAyB;AAAA;AAAA;AAAA,EAGjC,YAAwC;AAAA;AAlOhD;AAmOI,UAAI,aAAM,aAAa,eAAlB,mBAA8B,QAAO;AACxC,cAAM,IAAI,MAAM;AAAA;AAElB,aAAO,KAAK,IACV,oBACA,IACA;AAAA,QACE,SAAS,GAAG,2BAA2B,UAAU,WAAK,aAAa,eAAlB,mBAA8B;AAAA,SAEjF,KAAK,CAAC,MAAM,KAAK,WAAW;AAAA;AAAA;AAAA,EAG1B,UAAU,MAAc,QAA0C;AAAA;AA/O1E;AAgPI,UAAI,aAAM,aAAa,eAAlB,mBAA8B,QAAO;AACxC,cAAM,IAAI,MAAM;AAAA;AAElB,aAAO,KAAK,KACV,mBACA,EAAE,UAAU,MAAM,UAClB,EAAE,SAAS,GAAG,2BAA2B,UAAU,WAAK,aAAa,eAAlB,mBAA8B,aACjF,KAAK,CAAC,MAAM,KAAK,WAAW;AAAA;AAAA;AAAA,EAG1B,SAAmC;AAAA;AA1P3C;AA2PI,UAAI,aAAM,aAAa,eAAlB,mBAA8B,QAAO;AACxC,cAAM,IAAI,MAAM;AAAA;AAElB,aAAO,KAAK,KACV,cACA;AAAA,QACE,eAAe,WAAK,aAAa,SAAS,eAA3B,mBAAuC;AAAA,SAExD;AAAA,QACE,SAAS;AAAA,WACN,2BAA2B,UAAU,WAAK,aAAa,eAAlB,mBAA8B;AAAA;AAAA;AAAA;AAAA;AAAA,EAM5E,WAAoC,UAAgB;AAClD,QAAI,SAAS,cAAc;AACzB,WAAK,aAAa,UAAU,SAAS,cAAc;AAAA;AAErD,QAAI,SAAS,eAAe;AAC1B,WAAK,aAAa,UAAU,SAAS,eAAe;AAAA;AAEtD,WAAO;AAAA;AAAA;;MClRE,WAAW;MAIX,sBAAsB;MAGtB,kBAAkB;MAClB,0BAA0B;;ACRvC,oBAAoB;AAAA,EAApB;AACE,wBAAe;AAAA;AAAA,EAEf,YAAqB;AACnB,WAAO;AAAA;AAAA,EAGT,WAAmB;AACjB,UAAM,IAAI,MAAM;AAAA;AAAA,EAGlB,cAAoB;AAAA;AAAA;;ACTtB,qBAA6C;AAAA,EAW3C,YAAY,aAAgD,WAAoB,YAAqB;AAVrG,mBAAU;AAEV,uBAAiD;AAEjD,kBAAS,GAAG,KAAK;AAEjB,mBAAU,GAAG,KAAK;AAElB,wBAAe;AAGb,SAAK,SAAS,YAAY,KAAK,UAAU,YAAY,KAAK;AAC1D,SAAK,UAAU,aAAa,KAAK,UAAU,aAAa,KAAK;AAC7D,SAAK,cAAc;AAAA;AAAA,EAGrB,UAAU,OAAe,WAA+B;AACtD,QAAI,OAAO;AACT,aAAO,KAAK,aAAa,QAAQ,KAAK,YAAY;AAClD,aAAO;AAAA;AAET,WAAO;AAAA;AAAA,EAGT,SAAS,WAA8B;AA3BzC;AA4BI,WAAO,aAAO,KAAK,aAAa,QAAQ,KAAK,gBAAtC,YAAqD;AAAA;AAAA,EAG9D,YAAY,WAA4B;AACtC,WAAO,KAAK,aAAa,WAAW,KAAK;AAAA;AAAA;;AC9B7C,2BAA2B,eAAe;AAAA,EACxC,YAAY,WAAoB,YAAqB;AACnD,UAAM,gBAAgB,WAAW;AAAA;AAAA;;ACFrC,6BAA6B,eAAe;AAAA,EAC1C,YAAY,WAAoB,YAAqB;AACnD,UAAM,kBAAkB,WAAW;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;ACEvC,mBAAmB;AAAA,EAGjB,YAAY,cAA6B;AACvC,SAAK,eAAe,gBAAgB,IAAIC;AAAA;AAAA,EAKpC,mBAAmB,OAAe,UAAkB,QAAmC;AAAA;AAC3F,UAAI,CAAC,KAAK,aAAa;AAAc,eAAO;AAC5C,UAAI;AACF,cAAM,KAAK,cAAc,OAAO,UAAU;AAC1C,aAAK,UAAU;AACf,eAAO;AAAA,eACA,KAAP;AACA,aAAK;AACL,eAAO,QAAQ,OAAO;AAAA;AAAA;AAAA;AAAA,EAIpB,cAAc,OAAe,UAAkB,QAAmC;AAAA;AA3B1F;AA4BI,UAAI,CAAC;AAAO,cAAM,IAAI,MAAM;AAC5B,YAAM,aAAa,KAAK,SAAS;AACjC,YAAM,eAAe,KAAK,aAAa;AACvC,UAAI,kBAAW,QAAX,mBAAgB,SAAS,gBAAe,UAAU,WAAW,QAAQ,WAAW,CAAC,cAAc;AACjG,eAAO,QAAQ,QAAQ;AAAA;AAEzB,YAAM,IAAI,MAAM;AAAA;AAAA;AAAA,EAGlB,SAAS,OAA2B;AAClC,UAAM,YAAY,MAAM,MAAM,KAAK;AACnC,QAAI,CAAC;AAAW,aAAO,EAAE,KAAK,IAAI,KAAK,IAAI,KAAK;AAChD,UAAM,SAAS,UAAU,QAAQ,MAAM,KAAK,QAAQ,MAAM;AAC1D,UAAM,cAAc,mBAClB,KAAK,QACF,MAAM,IACN,IAAI,CAAC,MAAM,IAAI,KAAK,EAAE,WAAW,GAAG,SAAS,MAAM,MAAM,OACzD,KAAK;AAEV,WAAO,KAAK,MAAM;AAAA;AAAA,EAGpB,aAAa,OAA4B;AACvC,UAAM,MAAM,IAAI,OAAO,YAAY;AACnC,QAAI,MAAM,OAAO,MAAM,MAAM,KAAK;AAChC,aAAO;AAAA;AAET,WAAO;AAAA;AAAA,EAGT,gBAAgB,UAAkB,QAAmC;AACnE,QAAI,CAAC,KAAK,aAAa;AAAc,aAAO,QAAQ,QAAQ;AAC5D,UAAM,QAAQ,KAAK,aAAa,SAAS;AAEzC,WAAO,KAAK,cAAc,OAAO,UAAU;AAAA;AAAA,EAG7C,UAAU,OAAe,OAAkB,UAAmB;AAC5D,WAAO,KAAK,aAAa,UAAU,OAAO;AAAA;AAAA,EAG5C,YAAY,OAAkB,UAAgB;AAC5C,SAAK,aAAa,YAAY;AAAA;AAAA,EAGhC,SAAS,OAAkB,UAA8B;AACvD,UAAM,QAAQ,KAAK,aAAa,SAAS;AACzC,QAAI,CAAC;AAAO,aAAO;AACnB,UAAM,aAAa,KAAK,SAAS;AACjC,WAAO,EAAE,OAAO,SAAS;AAAA;AAAA;;iBC3EL;AAAA,EACtB,YAAoB,QAAwB;AAAxB;AAAA;AAAA,EAEpB,OAAO,MAAwB;AALjC;AAMI,UAAM,SAAS,YAAK,OAAO,WAAZ,mBAAoB,WAAU;AAC7C,UAAM,cAAc,mBAAmB,WAAK,OAAO,gBAAZ,YAA2B,OAAO,SAAS;AAClF,UAAM,aAAa,SAAS,KAAK,OAAO,gBAAgB;AACxD,UAAM,YAAY,GAAG,0BAA0B;AAE/C,UAAM,wBAAwB,KAAK,OAAO,wBACxC,gBAAgB,mBAAmB,KAAK,OAAO,2BAC/C,gBAAgB,2BAA2B,KAAK,OAAO,iBAAiB,mBAAmB;AAE7F,UAAM,OAAO;AAAA,MACX,QAAQ,GAAG,KAAK,OAAO,oBAAoB;AAAA,MAC3C,QAAQ,GAAG,KAAK,OAAO,iBAAiB;AAAA,MACxC,QAAQ,GAAG,KAAK,OAAO,kBAAkB,aAAa;AAAA,MACtD,OAAO,GAAG,KAAK,OAAO,uBAAuB,0BAA0B;AAAA,MACvE,SAAS;AAAA;AAGX,WAAO,KAAK,SAAS,KAAK;AAAA;AAAA,EAG5B,kBAA0B;AACxB,WAAO,KAAK,OAAO;AAAA;AAAA,EAGrB,kBAA0B;AACxB,WAAO,KAAK,OAAO;AAAA;AAAA,EAGrB,kBAA0B;AACxB,WAAO,KAAK,OAAO;AAAA;AAAA,EAGrB,wBAAgC;AAC9B,WAAO,KAAK,OAAO;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjCvB,mBAAmB;AAAA,EAajB,YAAY,QAAwB;AAJ5B,iBAA4B;AAEpC,kBAAS;AAjBX;AAoBI,SAAK,SAAS,iCAAK,SAAL,EAAa,WAAW,aAAO,cAAP,YAAoB;AAC1D,SAAK,eAAe,IAAI,aAAa,OAAO;AAC5C,SAAK,aAAa,IAAI,WAAW,KAAK;AACtC,SAAK,MAAM,IAAI,IAAI,QAAQ,KAAK;AAChC,SAAK,YAAY,YAAK,aAAa,eAAlB,mBAA8B,UAAS,IAAI;AAAA;AAAA,EAGtD,YAAY,OAAe,WAAiC;AAClE,QAAI,OAAO;AACT,UAAI,cAAc,UAAU;AAC1B,cAAM,UAAU,KAAK,aAAa,SAAS;AAC3C,aAAK,QAAQ,EAAE,OAAO;AACtB,aAAK,SAAS;AACd,aAAK,aAAa,UAAU;AAAA,aACvB;AACL,aAAK,aAAa,UAAU,OAAO;AAAA;AAAA;AAAA;AAAA,EAKjC,kBAAkB;AACxB,SAAK,QAAQ;AACb,SAAK,SAAS;AACd,SAAK,aAAa;AAClB,SAAK,aAAa,YAAY;AAAA;AAAA,EAGhC,SAAe;AACb,WAAO,SAAS,OAAO,KAAK,WAAW;AAAA;AAAA,EAGzC,SAAe;AACb,WAAO,SAAS,OAAO,KAAK,WAAW;AAAA;AAAA,EAGzC,SAAe;AACb,SAAK;AACL,WAAO,SAAS,OAAO,KAAK,WAAW;AAAA;AAAA,EAGnC,uBAAyC;AAAA;AAC7C,YAAM,EAAE,QAAQ,YAAY,KAAK;AACjC,UAAI,CAAC,QAAQ;AACX,aAAK;AACL,eAAO,QAAQ;AAAA;AAEjB,UAAI;AACF,cAAM,KAAK,aAAa,mBAAmB,QAAQ,KAAK,OAAO,OAAO,KAAK,OAAO;AAClF,aAAK,YAAY,QAAQ;AACzB,YAAI,SAAS;AACX,eAAK,YAAY,SAAS;AAAA;AAE5B,eAAO,MAAM,QAAQ,QAAQ;AAAA,eACtB,KAAP;AACA,aAAK;AACL,eAAO,MAAM,QAAQ;AAAA,gBACrB;AACA,eAAO,QAAQ,UAAU,IAAI,SAAS,OAAO,OAAO,SAAS;AAAA;AAAA;AAAA;AAAA,EAIzD,kBAAuD;AAC7D,UAAM,YAAY,IAAI,gBAAgB,OAAO,SAAS;AACtD,UAAM,SAAS,EAAE,QAAQ,IAAI,SAAS;AACtC,UAAM,cAAc,UAAU,IAAI;AAClC,UAAM,eAAe,UAAU,IAAI;AACnC,QAAI,gBAAgB,SAAS,KAAK,eAAe;AAC/C,aAAO,UAAU;AAAA;AAEnB,QAAI,eAAe,SAAS,KAAK,cAAc;AAC7C,aAAO,SAAS;AAAA;AAElB,WAAO;AAAA;AAAA,EAGH,WAAwC;AAAA;AAC5C,YAAM,QAAQ,KAAK,aAAa;AAChC,YAAM,eAAe,KAAK,aAAa,SAAS;AAChD,UAAI,OAAO;AACT,cAAM,YAAY,KAAK,aAAa,aAAa,MAAM;AACvD,YAAI,aAAa,cAAc;AAC7B,cAAI;AACF,kBAAM,KAAK;AACX,mBAAO,MAAM,QAAQ,QAAQ,KAAK;AAAA,mBAC3B,KAAP;AACA,iBAAK;AACL,kBAAM,IAAI,MAAM;AAAA;AAAA;AAGpB,eAAO,QAAQ,QAAQ;AAAA;AAEzB,aAAO,QAAQ,QAAQ;AAAA;AAAA;AAAA,EAGnB,eAAgC;AAAA;AACpC,UAAI;AACF,cAAM,EAAE,QAAQ,YAAY,MAAM,KAAK;AACvC,aAAK,YAAY,QAAQ;AACzB,aAAK,YAAY,SAAS;AAC1B,eAAO,MAAM,QAAQ,QAAQ;AAAA,eACtB,KAAP;AACA,eAAO,QAAQ;AAAA;AAAA;AAAA;AAAA,EAIL,wBAAsE;AAAA;AAClF,UAAI;AACF,cAAM,SAAS,MAAM,KAAK,IAAI,aAC3B,KAAK,CAAC,SAAS,QAAQ,EAAE,gBAAgB,IAAI,SAAS,EAAE,iBAAiB;AAC5E,eAAO;AAAA,eACA,KAAP;AACA,eAAO,QAAQ,OAAO;AAAA;AAAA;AAAA;AAAA;;;;;;;;"}