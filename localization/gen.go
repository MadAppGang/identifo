//go:build ignore

package main // import "golang.org/x/tools/cmd/stringer"

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

func main() {
	g := Generator{}

	// Print the header and package clause.
	g.Printf("// Code generated by \"./gen.go\"; DO NOT EDIT.\n")
	g.Printf("\n")
	g.Printf("package localization")
	g.Printf("\n")
	g.Printf("const (\n")

	// TODO: Jack we need iterate all files for all language and compare that they have the same set of keys
	// TODO: otherwise we need to generate warning constants for missing const for each language
	file, err := os.Open("./translations/en.yaml")
	defer file.Close()

	if err != nil {
		log.Fatalf("read file ./translations/en.yaml error  #%v ", err)
	}

	scanner := bufio.NewScanner(file)
	scanner.Split(bufio.ScanLines)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		// if it is the string
		if strings.HasPrefix(line, "#") {
			g.Printf("\n\n\t//===========================================================================\n")
			g.Printf("\t// %s\n", strings.TrimLeft(line, "#"))
			g.Printf("\t//===========================================================================\n")
			continue
		}
		kv := strings.Split(line, ":")
		if len(kv) == 2 {
			cn := constName(kv[0])
			g.Printf("\t// %s -> %s\n", cn, kv[1])
			g.Printf("\t%s = \"%s\"\n", cn, kv[0])
		}

	}

	// yf, err := ioutil.ReadFile("./translations/en.yaml")
	// if err != nil {
	// 	log.Fatalf("yamlFile.Get err   #%v ", err)
	// }
	// lines := map[string]string{}
	// err = yaml.Unmarshal(yf, &lines)
	// if err != nil {
	// 	log.Fatalf("Unmarshal: %v", err)
	// }
	// for key, value := range lines {
	// 	cn := constName(key)
	// 	g.Printf("\t// %s -> %s\n", cn, value)
	// 	g.Printf("\t%s = \"%s\"\n", cn, key)
	// }

	g.Printf(")\n")
	// Format the output.
	src := g.format()
	err = os.WriteFile("./messages_const.go", src, 0o644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

func constName(key string) string {
	k := strings.ReplaceAll(key, ".", " ")
	k = strings.ReplaceAll(k, "_", " ")
	k = cases.Title(language.Und).String(k)
	k = strings.ReplaceAll(k, " ", "")
	return k
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}
