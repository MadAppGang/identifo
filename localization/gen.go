//go:build ignore

package main // import "golang.org/x/tools/cmd/stringer"

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

func main() {
	g := Generator{}

	// Print the header and package clause.
	g.Printf("// Code generated by \"./gen.go\"; DO NOT EDIT.\n")
	g.Printf("\n")
	g.Printf("package localization")
	g.Printf("\n")
	g.Printf("type LocalizedString string\n")
	g.Printf("const (\n")

	// TODO: Jack we need iterate all files for all language and compare that they have the same set of keys
	// TODO: otherwise we need to generate warning constants for missing const for each language
	file, err := os.Open("./translations/en.yaml")
	defer file.Close()

	if err != nil {
		log.Fatalf("read file ./translations/en.yaml error  #%v ", err)
	}

	scanner := bufio.NewScanner(file)
	scanner.Split(bufio.ScanLines)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		// if it is the string
		if strings.HasPrefix(line, "#") {
			g.Printf("\n\n\t//===========================================================================\n")
			g.Printf("\t// %s\n", strings.TrimLeft(line, "#"))
			g.Printf("\t//===========================================================================\n")
			continue
		}

		k, v := getKeyValue(line)
		if len(k) > 0 {
			cn := constName(k)
			g.Printf("\t// %s -> %s\n", cn, v)
			g.Printf("\t%s LocalizedString = \"%s\"\n", cn, k)
		}

	}

	g.Printf(")\n")
	// Format the output.
	src := g.format()
	err = os.WriteFile("./messages_const.go", src, 0o644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

func constName(key string) string {
	k := strings.ReplaceAll(key, ".", " ")
	k = strings.ReplaceAll(k, "_", " ")
	k = cases.Title(language.Und).String(k)
	k = strings.ReplaceAll(k, " ", "")
	k = strings.ReplaceAll(k, "Api", "API")
	k = strings.ReplaceAll(k, "App", "APP")
	k = strings.ReplaceAll(k, "2Fa", "2FA")
	k = strings.ReplaceAll(k, "Id", "ID")
	return k
}

func getKeyValue(s string) (string, string) {
	pos := strings.Index(s, ":") // get the first colon index
	if pos < 1 {
		return "", ""
	}

	v := strings.TrimSpace(s[pos+1:])
	v = strings.Trim(v, "\"")

	return strings.TrimSpace(s[:pos]), v
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}
